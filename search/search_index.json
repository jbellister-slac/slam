{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SLAC Alarm Manager","text":"<p>The SLAC Alarm Manager is a python package providing an interface to the NALMS alarm system. It contains two main ways of interacting with NALMS. There is a standalone python application for viewing and interacting with alarms described in greater detail here. And a PyDM data plugin that will allow for building PyDM displays containing summary alarms.</p>"},{"location":"#installation","title":"Installation","text":"<p>The easiest installation method is using pip to install from PyPI into a virtual environment:</p> <p><code>pip install slac-alarm-manager</code></p> <p>It can also be installed from source using pip from the repository here: https://github.com/slaclab/slac-alarm-manager</p>"},{"location":"#setting-up-alarm-configurations","title":"Setting up Alarm Configurations","text":"<p>The alarm hierarchies displayed in this system are defined using xml files. As an example, we can look at this file:</p> <p>https://github.com/pcdshub/pcds-nalms/blob/master/XML/KFE/GMDXGMD.xml</p> <p>The top level config name, <code>nalms-kfe-GMDXGMD</code>, represents the system being monitored. It will also be referred to as the alarm topic or kafka topic in the rest of this documentation. A component is a way of grouping PVs together in whatever way makes sense. For more information about the valid options for each pv, please see the description of these at the NALMS documentation here: https://slaclab.github.io/nalms/configuration/.</p>"},{"location":"alarm_manager/","title":"Alarm Manager","text":"<p>Since the alarm server and logger are both built with Phoebus, many of the interface details and actions described here will be familiar to anyone who has used the Phoebus alarm interface in the past.</p> <p>NOTE</p> <p>This alarm manager interacts with NALMS only, and does not directly communicate using EPICS with any IOCs. Therefore all actions available from the interface are write-safe when it comes to EPICS - nothing will write back to any PV.</p>"},{"location":"alarm_manager/#starting-the-alarm-manager","title":"Starting the Alarm Manager","text":"<p>As this application is a frontend interface to NALMS, a running NALMS instance is required. The specific component which the alarm manager will be communicating with is kafka.</p> <p>Both the location of the kafka instance, and the alarm topics which should be monitored are required arguments upon startup.</p> <p>From a terminal window with the python environment that the alarm manager was installed into active, run the following command, replacing the name of the topic and the location of kafka as appropriate:</p> <p><code>slam --topics Demo --bootstrap-servers localhost:9092</code></p> <p>It is possible for the interface to monitor multiple topics at once if passed a comma-separated list:</p> <p><code>slam --topics Demo,Accelerator,Cryoplant --bootstrap-servers localhost:9092</code></p> <p>In an ideal scenario, the main window will look something like this:</p> <p></p> <p>The panel to the left of the window is the tree view of all the alarms being monitored. It will match the alarm hierarchy defined in the xml config file above. To the right are two tables, the top one will display PVs which are in an active alarm state, the bottom one will display acknowledged alarms (more on this later).</p>"},{"location":"alarm_manager/#active-alarms","title":"Active Alarms","text":"<p>In order to make this display a little more interesting, let's run a few caput commands to get PVs into an alarm state:</p> <p></p> <p>When a PV moves into an alarm state, it is reflected both in the change to the alarm tree, as well as the addition to the active alarm table. Note that when a PV returns to a normal alarm status, the corresponding entry is removed from the alarm table. This behavior is caused by the <code>latched</code> option. If <code>latched</code> is set to true, then the alarm will remain in the table until someone manually acknowledges it (see the next section). The purpose would be to set the latched status to true for any alarm which requires someone to look into why it happened, even if it returns to normal on its own.</p>"},{"location":"alarm_manager/#acknowledging-and-bypassing-alarms","title":"Acknowledging and Bypassing Alarms","text":"<p>When a PV or top level group has gone into an alarm status, right-clicking on it will bring up a menu for taking additional actions on the alarm.</p> <p>The first of these actions is to acknowledge it. This basically means that someone is aware that the PV is now in an alarm state, and action is being taken to correct that. Upon clicking on acknowledge, note that the alarm status changes, and it is moved to the bottom table for acknowledged alarms:</p> <p></p> <p>As can be seen in the example, multiple alarms in a group can be acknowledged at once by acknowledging thier top-level summary alarm. And if an acknowledgment is done by accident, it can be reverted with the same right-click menu and choosing unacknowledge.</p> <p>The other important action there is to enable or disable an alarm. Disabling an alarm will stop any future updates to the underlying PV(s) from being displayed until it is re-enabled. One example where this is useful is if a component is undergoing planned maintenance and so there is no need for any alarms to trigger until the maintenance has been completed.</p> <p>Finally the remaining two options are to copy the name of the PV to the clipboard, and to draw a plot of the PV in a separate window. This plot is rendered using PyDM.</p>"},{"location":"alarm_manager/#additional-options-menu","title":"Additional Options Menu","text":"<p>By double-clicking on a PV in the alarm tree, a menu will be brought up displaying a few additional options as well as more information.</p> <p></p> <p>The <code>Disable Until</code> option will bypass an alarm as described above, except with a specified end time set. Once that time is reached, the alarm will automatically be re-enabled. In the above maintenance example, this can be useful to ensure someone does not need to remember to manually re-enable the alarm once the maintenance is completed.</p> <p>The <code>Alarm Delay</code> represents how long the PV must be in an alarm state before triggering the alarm. The default is to raise an alarm immediately, but this can be increased if temporary fluctuations in values are to be expected.</p> <p>Information under guidance is free-form and can be used to indicate information like who to call if a certain PV or component goes into an alarm state.</p> <p>Please note that any information entered here while the application is running will NOT be persisted when the associated alarm server is updated or restarted. To ensure persistence, all information must be saved in the xml configuration file.</p>"},{"location":"developer/","title":"Developer Information","text":"<p>This section includes some additional information that will be useful to anyone who wishes to build their own interface to NALMS in a similar fashion to either the alarm manager or the PyDM data plugin. Or anyone just looking for a few extra technical details.</p> <p>This documentation is still under development, will be updated soon.</p>"},{"location":"pydm/","title":"PyDM Support","text":"<p>PyDM is a python based framework for building interfaces for control systems described in more detail here. PyDM is able to read in data from multiple sources via data plugins, allowing a standard way for UI widgets to receive and display data.</p> <p>One such data plugin is included with the slac-alarm-manager package. An associated entrypoint will cause PyDM to automatically discover this data plugin and allow the user to build displays that include data from the alarm system.</p>"},{"location":"pydm/#what-are-summary-alarms","title":"What Are Summary Alarms?","text":"<p>Since PyDM already includes built-in support for fetching and displaying the alarm status of individual PVs, the main benefit of this new plugin is for the display of summary alarms. A summary alarm is one which comprises a number of underlying PVs or (other summary alarms). As an example, let's take an alarm hierarchy that looks like this:</p> <p></p> <p>Where the associated xml file describing the structure could look as follows:</p> <pre><code>&lt;?xml version='1.0' encoding='utf8'?&gt;\n&lt;config name=\"Demo\"&gt;\n    &lt;component name=\"GROUP1\"&gt;\n        &lt;pv name=\"DEMO:PV1\"&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/pv&gt;\n        &lt;pv name=\"DEMO:PV2\"&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/pv&gt;\n        &lt;pv name=\"DEMO:PV3\"&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/pv&gt;\n    &lt;/component&gt;\n    &lt;component name=\"GROUP2\"&gt;\n        &lt;component name=\"GROUP3\"&gt;\n            &lt;pv name=\"DEMO:PV4\"&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/pv&gt;\n            &lt;pv name=\"DEMO:PV5\"&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/pv&gt;\n        &lt;/component&gt;\n        &lt;pv name=\"DEMO:PV6\"&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/pv&gt;\n        &lt;pv name=\"DEMO:PV7\"&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/pv&gt;\n    &lt;/component&gt;\n&lt;/config&gt;\n</code></pre> <p>Here <code>GROUP1</code> is a top level summary that will reflect the highest severity alarm from <code>DEMO:PV1</code>, <code>DEMO:PV2</code>, and <code>DEMO:PV3</code>. <code>GROUP2</code> will do the same for its underlying components, one of which (<code>GROUP3</code>) is a summary alarm itself. So if say <code>DEMO:PV2</code> goes into a minor alarm state, and <code>DEMO:PV3</code> into a major, then <code>GROUP1</code> will go into a major alarm state as well. If <code>DEMO:PV3</code> returns to normal, then <code>GROUP1</code> will go into a minor alarm state as <code>DEMO:PV2</code> now has the highest severity among its components.</p> <p>We will create an example display based on this alarm hierarchy to show this and the PyDM/NALMS integration in action.</p>"},{"location":"pydm/#creating-a-sample-display","title":"Creating a Sample Display","text":"<p>To keep this display simple, we will just drop some PyDMFrame widgets onto it along with associated labels identifying each summary alarm or PV being represented:</p> <p></p> <p>Next we'll connect each to a channel. The new <code>nalms://</code> protocol has been added as a way to communicate with the alarm system. Using this protocol is required for the summary alarms as there is no actual IOC backing any of them. But as shown in this demo, using either regular channel access or <code>nalms://</code> is fine when dealing with individual PVs:</p> <p></p>"},{"location":"pydm/#running-the-display","title":"Running the Display","text":"<p>To see the display working, first ensure that the following two environment variables are set to the correct value of the alarm topic to monitor, as well as the location of the kafka cluster. For this demo:</p> <pre><code>export PYDM_KAFKA_ALARM_TOPICS=Demo\nexport PYDM_KAFKA_BOOTSTRAP_SERVERS=localhost:9092\n</code></pre> <p>Now with an instance of this display running, we can issue caput commands in order to toggle the PVs into various alarm states. Here a minor alarm is represented by the darkened single border around a frame, and a major by the red double border. You can see that the summary alarms will automatically take on the highest alarm state of any of its underlying PVs as described above:</p> <p></p> <p>As a final note, the <code>nalms://</code> protocol should work with any widget which supports displaying alarm status, so more complex displays than this can be created, for example with related display buttons to drill down into the components of a system. And it is also possible to have the same PV as part of multiple summary alarms if needed.</p>"}]}